"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _constants = require("../constants");

var _baseMode = _interopRequireDefault(require("./base-mode"));

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class EditingMode extends _baseMode.default {
  constructor() {
    var _this;

    super(...arguments);
    _this = this;

    _defineProperty(this, "handleClick", function (event, props) {
      var pickedObject = event.picks && event.picks[0] && event.picks[0].object;
      var selectedFeatureIndex = props.selectedIndexes && props.selectedIndexes[0];

      if (!pickedObject || pickedObject.featureIndex !== selectedFeatureIndex) {
        return;
      }

      var featureIndex = pickedObject.featureIndex,
          index = pickedObject.index;

      var feature = _this.getSelectedFeature(props, featureIndex);

      if (feature && (feature.geometry.type === _constants.RENDER_TYPE.POLYGON || feature.geometry.type === _constants.RENDER_TYPE.LINE_STRING) && pickedObject.type === _constants.ELEMENT_TYPE.SEGMENT) {
        var coordinates = (0, _utils.getFeatureCoordinates)(feature);

        if (!coordinates) {
          return;
        }

        var insertIndex = (index + 1) % coordinates.length;
        var positionIndexes = feature.geometry.type === _constants.RENDER_TYPE.POLYGON ? [0, insertIndex] : [insertIndex];

        var insertMapCoords = _this._getPointOnSegment(feature, pickedObject, event.mapCoords);

        var updatedData = props.data.addPosition(featureIndex, positionIndexes, insertMapCoords).getObject();
        props.onEdit({
          editType: _constants.EDIT_TYPE.ADD_POSITION,
          updatedData: updatedData,
          editContext: [{
            featureIndex: featureIndex,
            editHandleIndex: insertIndex,
            screenCoords: props.viewport && props.viewport.project(insertMapCoords),
            mapCoords: insertMapCoords
          }]
        });
      }
    });

    _defineProperty(this, "_handleDragging", function (event, props) {
      var onEdit = props.onEdit;

      var selectedFeature = _this.getSelectedFeature(props); // nothing clicked


      var isDragging = event.isDragging,
          pointerDownPicks = event.pointerDownPicks,
          screenCoords = event.screenCoords;
      var lastPointerMoveEvent = props.lastPointerMoveEvent;
      var clickedObject = pointerDownPicks && pointerDownPicks[0] && pointerDownPicks[0].object;

      if (!clickedObject || !(0, _utils.isNumeric)(clickedObject.featureIndex)) {
        return;
      }

      var editHandleIndex = clickedObject.index; // not dragging

      var updatedData = null;
      var editType = isDragging ? _constants.EDIT_TYPE.MOVE_POSITION : _constants.EDIT_TYPE.FINISH_MOVE_POSITION;

      switch (clickedObject.type) {
        case _constants.ELEMENT_TYPE.FEATURE:
        case _constants.ELEMENT_TYPE.FILL:
        case _constants.ELEMENT_TYPE.SEGMENT:
          // dragging feature
          var dx = screenCoords[0] - lastPointerMoveEvent.screenCoords[0];
          var dy = screenCoords[1] - lastPointerMoveEvent.screenCoords[1];
          updatedData = _this._updateFeature(props, 'feature', {
            dx: dx,
            dy: dy
          });
          onEdit({
            editType: editType,
            updatedData: updatedData,
            editContext: null
          });
          break;

        case _constants.ELEMENT_TYPE.EDIT_HANDLE:
          // dragging editHandle
          // dragging rectangle or other shapes
          var updateType = selectedFeature.properties.renderType === _constants.RENDER_TYPE.RECTANGLE ? 'rectangle' : 'editHandle';
          updatedData = _this._updateFeature(props, updateType, {
            editHandleIndex: editHandleIndex,
            mapCoords: event.mapCoords
          });
          onEdit({
            editType: editType,
            updatedData: updatedData,
            editContext: null
          });
          break;

        default:
      }
    });

    _defineProperty(this, "handlePointerMove", function (event, props) {
      // no selected feature
      var selectedFeature = _this.getSelectedFeature(props);

      if (!selectedFeature) {
        return;
      }

      if (!event.isDragging) {
        return;
      }

      _this._handleDragging(event, props);
    });

    _defineProperty(this, "_updateFeature", function (props, type) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var data = props.data,
          selectedIndexes = props.selectedIndexes,
          viewport = props.viewport;
      var featureIndex = selectedIndexes && selectedIndexes[0];

      var feature = _this.getSelectedFeature(props, featureIndex);

      var geometry = null;
      var coordinates = (0, _utils.getFeatureCoordinates)(feature);

      if (!coordinates) {
        return null;
      }

      var newCoordinates = _toConsumableArray(coordinates);

      switch (type) {
        case 'editHandle':
          var positionIndexes = feature.geometry.type === _constants.GEOJSON_TYPE.POLYGON ? [0, options.editHandleIndex] : [options.editHandleIndex];
          return data.replacePosition(featureIndex, positionIndexes, options.mapCoords).getObject();

        case 'feature':
          var dx = options.dx,
              dy = options.dy;
          newCoordinates = newCoordinates.map(function (mapCoords) {
            var pixels = viewport && viewport.project(mapCoords);

            if (pixels) {
              pixels[0] += dx;
              pixels[1] += dy;
              return viewport && viewport.unproject(pixels);
            }

            return null;
          }).filter(Boolean);
          geometry = {
            type: feature.geometry.type,
            coordinates: feature.geometry.type === _constants.GEOJSON_TYPE.POLYGON ? [newCoordinates] : newCoordinates
          };
          return data.replaceGeometry(featureIndex, geometry).getObject();

        case 'rectangle':
          // moved editHandleIndex and destination mapCoords
          newCoordinates = (0, _utils.updateRectanglePosition)(feature, options.editHandleIndex, options.mapCoords);
          geometry = {
            type: _constants.GEOJSON_TYPE.POLYGON,
            coordinates: newCoordinates
          };
          return data.replaceGeometry(featureIndex, geometry).getObject();

        default:
          return data && data.getObject();
      }
    });

    _defineProperty(this, "_getCursorEditHandle", function (event, feature) {
      var isDragging = event.isDragging,
          picks = event.picks; // if not pick segment

      var pickedObject = picks && picks[0] && picks[0].object;

      if (!pickedObject || !(0, _utils.isNumeric)(pickedObject.featureIndex) || pickedObject.type !== _constants.ELEMENT_TYPE.SEGMENT) {
        return null;
      } // if dragging or feature is neither polygon nor line string


      if (isDragging || feature.properties.renderType !== _constants.GEOJSON_TYPE.POLYGON && feature.properties.renderType !== _constants.GEOJSON_TYPE.LINE_STRING) {
        return null;
      }

      var insertMapCoords = _this._getPointOnSegment(feature, pickedObject, event.mapCoords);

      if (!insertMapCoords) {
        return null;
      }

      return {
        type: 'Feature',
        properties: {
          guideType: _constants.GUIDE_TYPE.CURSOR_EDIT_HANDLE,
          renderType: feature.properties.renderType,
          positionIndexes: [null]
        },
        geometry: {
          type: _constants.GEOJSON_TYPE.POINT,
          coordinates: [insertMapCoords]
        }
      };
    });

    _defineProperty(this, "getGuides", function (props) {
      var selectedFeature = _this.getSelectedFeature(props);

      var selectedFeatureIndex = props.selectedIndexes && props.selectedIndexes[0];

      if (!selectedFeature || selectedFeature.geometry.type === _constants.GEOJSON_TYPE.POINT) {
        return null;
      }

      var event = props.lastPointerMoveEvent; // feature editHandles

      var editHandles = _this.getEditHandlesFromFeature(selectedFeature, selectedFeatureIndex) || []; // cursor editHandle

      var cursorEditHandle = _this._getCursorEditHandle(event, selectedFeature);

      if (cursorEditHandle) {
        editHandles.push(_this._getCursorEditHandle(event, selectedFeature));
      }

      return {
        editHandles: editHandles.length ? editHandles : null
      };
    });
  }

  handleStopDragging(event, props) {
    // replace point
    var pickedObject = event.picks && event.picks[0] && event.picks[0].object;

    if (!pickedObject || !(0, _utils.isNumeric)(pickedObject.featureIndex)) {
      return;
    }

    switch (pickedObject.type) {
      case _constants.ELEMENT_TYPE.FEATURE:
      case _constants.ELEMENT_TYPE.EDIT_HANDLE:
        this._handleDragging(event, props);

        break;

      default:
    }
  }

  _getPointOnSegment(feature, pickedObject, pickedMapCoords) {
    var coordinates = (0, _utils.getFeatureCoordinates)(feature);

    if (!coordinates) {
      return null;
    }

    var srcVertexIndex = pickedObject.index;
    var targetVertexIndex = pickedObject.index + 1;
    return (0, _utils.findClosestPointOnLineSegment)(coordinates[srcVertexIndex], coordinates[targetVertexIndex], pickedMapCoords);
  }

}

exports.default = EditingMode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9lZGl0LW1vZGVzL2VkaXRpbmctbW9kZS5qcyJdLCJuYW1lcyI6WyJFZGl0aW5nTW9kZSIsIkJhc2VNb2RlIiwiZXZlbnQiLCJwcm9wcyIsInBpY2tlZE9iamVjdCIsInBpY2tzIiwib2JqZWN0Iiwic2VsZWN0ZWRGZWF0dXJlSW5kZXgiLCJzZWxlY3RlZEluZGV4ZXMiLCJmZWF0dXJlSW5kZXgiLCJpbmRleCIsImZlYXR1cmUiLCJnZXRTZWxlY3RlZEZlYXR1cmUiLCJnZW9tZXRyeSIsInR5cGUiLCJSRU5ERVJfVFlQRSIsIlBPTFlHT04iLCJMSU5FX1NUUklORyIsIkVMRU1FTlRfVFlQRSIsIlNFR01FTlQiLCJjb29yZGluYXRlcyIsImluc2VydEluZGV4IiwibGVuZ3RoIiwicG9zaXRpb25JbmRleGVzIiwiaW5zZXJ0TWFwQ29vcmRzIiwiX2dldFBvaW50T25TZWdtZW50IiwibWFwQ29vcmRzIiwidXBkYXRlZERhdGEiLCJkYXRhIiwiYWRkUG9zaXRpb24iLCJnZXRPYmplY3QiLCJvbkVkaXQiLCJlZGl0VHlwZSIsIkVESVRfVFlQRSIsIkFERF9QT1NJVElPTiIsImVkaXRDb250ZXh0IiwiZWRpdEhhbmRsZUluZGV4Iiwic2NyZWVuQ29vcmRzIiwidmlld3BvcnQiLCJwcm9qZWN0Iiwic2VsZWN0ZWRGZWF0dXJlIiwiaXNEcmFnZ2luZyIsInBvaW50ZXJEb3duUGlja3MiLCJsYXN0UG9pbnRlck1vdmVFdmVudCIsImNsaWNrZWRPYmplY3QiLCJNT1ZFX1BPU0lUSU9OIiwiRklOSVNIX01PVkVfUE9TSVRJT04iLCJGRUFUVVJFIiwiRklMTCIsImR4IiwiZHkiLCJfdXBkYXRlRmVhdHVyZSIsIkVESVRfSEFORExFIiwidXBkYXRlVHlwZSIsInByb3BlcnRpZXMiLCJyZW5kZXJUeXBlIiwiUkVDVEFOR0xFIiwiX2hhbmRsZURyYWdnaW5nIiwib3B0aW9ucyIsIm5ld0Nvb3JkaW5hdGVzIiwiR0VPSlNPTl9UWVBFIiwicmVwbGFjZVBvc2l0aW9uIiwibWFwIiwicGl4ZWxzIiwidW5wcm9qZWN0IiwiZmlsdGVyIiwiQm9vbGVhbiIsInJlcGxhY2VHZW9tZXRyeSIsImd1aWRlVHlwZSIsIkdVSURFX1RZUEUiLCJDVVJTT1JfRURJVF9IQU5ETEUiLCJQT0lOVCIsImVkaXRIYW5kbGVzIiwiZ2V0RWRpdEhhbmRsZXNGcm9tRmVhdHVyZSIsImN1cnNvckVkaXRIYW5kbGUiLCJfZ2V0Q3Vyc29yRWRpdEhhbmRsZSIsInB1c2giLCJoYW5kbGVTdG9wRHJhZ2dpbmciLCJwaWNrZWRNYXBDb29yZHMiLCJzcmNWZXJ0ZXhJbmRleCIsInRhcmdldFZlcnRleEluZGV4Il0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBWUE7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBT2UsTUFBTUEsV0FBTixTQUEwQkMsaUJBQTFCLENBQW1DO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBLHlDQUNsQyxVQUFDQyxLQUFELEVBQW9CQyxLQUFwQixFQUE0RDtBQUN4RSxVQUFNQyxZQUFZLEdBQUdGLEtBQUssQ0FBQ0csS0FBTixJQUFlSCxLQUFLLENBQUNHLEtBQU4sQ0FBWSxDQUFaLENBQWYsSUFBaUNILEtBQUssQ0FBQ0csS0FBTixDQUFZLENBQVosRUFBZUMsTUFBckU7QUFDQSxVQUFNQyxvQkFBb0IsR0FBR0osS0FBSyxDQUFDSyxlQUFOLElBQXlCTCxLQUFLLENBQUNLLGVBQU4sQ0FBc0IsQ0FBdEIsQ0FBdEQ7O0FBQ0EsVUFBSSxDQUFDSixZQUFELElBQWlCQSxZQUFZLENBQUNLLFlBQWIsS0FBOEJGLG9CQUFuRCxFQUF5RTtBQUN2RTtBQUNEOztBQUx1RSxVQU9oRUUsWUFQZ0UsR0FPeENMLFlBUHdDLENBT2hFSyxZQVBnRTtBQUFBLFVBT2xEQyxLQVBrRCxHQU94Q04sWUFQd0MsQ0FPbERNLEtBUGtEOztBQVF4RSxVQUFNQyxPQUFPLEdBQUcsS0FBSSxDQUFDQyxrQkFBTCxDQUF3QlQsS0FBeEIsRUFBK0JNLFlBQS9CLENBQWhCOztBQUNBLFVBQ0VFLE9BQU8sS0FD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LGVBSEssQ0FBUDtBQUtEOztBQW5OK0MiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuXG5pbXBvcnQgdHlwZSB7XG4gIEZlYXR1cmUsXG4gIEZlYXR1cmVDb2xsZWN0aW9uLFxuICBDbGlja0V2ZW50LFxuICBTdG9wRHJhZ2dpbmdFdmVudCxcbiAgUG9pbnRlck1vdmVFdmVudCxcbiAgUG9zaXRpb25cbn0gZnJvbSAna2VwbGVyLW91dGRhdGVkLW5lYnVsYS5nbC1lZGl0LW1vZGVzJztcbmltcG9ydCB0eXBlIHsgTW9kZVByb3BzIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBSRU5ERVJfVFlQRSwgRURJVF9UWVBFLCBFTEVNRU5UX1RZUEUsIEdFT0pTT05fVFlQRSwgR1VJREVfVFlQRSB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgQmFzZU1vZGUgZnJvbSAnLi9iYXNlLW1vZGUnO1xuaW1wb3J0IHtcbiAgZmluZENsb3Nlc3RQb2ludE9uTGluZVNlZ21lbnQsXG4gIGdldEZlYXR1cmVDb29yZGluYXRlcyxcbiAgaXNOdW1lcmljLFxuICB1cGRhdGVSZWN0YW5nbGVQb3NpdGlvblxufSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRWRpdGluZ01vZGUgZXh0ZW5kcyBCYXNlTW9kZSB7XG4gIGhhbmRsZUNsaWNrID0gKGV2ZW50OiBDbGlja0V2ZW50LCBwcm9wczogTW9kZVByb3BzPEZlYXR1cmVDb2xsZWN0aW9uPikgPT4ge1xuICAgIGNvbnN0IHBpY2tlZE9iamVjdCA9IGV2ZW50LnBpY2tzICYmIGV2ZW50LnBpY2tzWzBdICYmIGV2ZW50LnBpY2tzWzBdLm9iamVjdDtcbiAgICBjb25zdCBzZWxlY3RlZEZlYXR1cmVJbmRleCA9IHByb3BzLnNlbGVjdGVkSW5kZXhlcyAmJiBwcm9wcy5zZWxlY3RlZEluZGV4ZXNbMF07XG4gICAgaWYgKCFwaWNrZWRPYmplY3QgfHwgcGlja2VkT2JqZWN0LmZlYXR1cmVJbmRleCAhPT0gc2VsZWN0ZWRGZWF0dXJlSW5kZXgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7IGZlYXR1cmVJbmRleCwgaW5kZXggfSA9IHBpY2tlZE9iamVjdDtcbiAgICBjb25zdCBmZWF0dXJlID0gdGhpcy5nZXRTZWxlY3RlZEZlYXR1cmUocHJvcHMsIGZlYXR1cmVJbmRleCk7XG4gICAgaWYgKFxuICAgICAgZmVhdHVyZSAmJlxuICAgICAgKGZlYXR1cmUuZ2VvbWV0cnkudHlwZSA9PT0gUkVOREVSX1RZUEUuUE9MWUdPTiB8fFxuICAgICAgICBmZWF0dXJlLmdlb21ldHJ5LnR5cGUgPT09IFJFTkRFUl9UWVBFLkxJTkVfU1RSSU5HKSAmJlxuICAgICAgcGlja2VkT2JqZWN0LnR5cGUgPT09IEVMRU1FTlRfVFlQRS5TRUdNRU5UXG4gICAgKSB7XG4gICAgICBjb25zdCBjb29yZGluYXRlcyA9IGdldEZlYXR1cmVDb29yZGluYXRlcyhmZWF0dXJlKTtcbiAgICAgIGlmICghY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaW5zZXJ0SW5kZXggPSAoaW5kZXggKyAxKSAlIGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICAgIGNvbnN0IHBvc2l0aW9uSW5kZXhlcyA9XG4gICAgICAgIGZlYXR1cmUuZ2VvbWV0cnkudHlwZSA9PT0gUkVOREVSX1RZUEUuUE9MWUdPTiA/IFswLCBpbnNlcnRJbmRleF0gOiBbaW5zZXJ0SW5kZXhdO1xuICAgICAgY29uc3QgaW5zZXJ0TWFwQ29vcmRzID0gdGhpcy5fZ2V0UG9pbnRPblNlZ21lbnQoZmVhdHVyZSwgcGlja2VkT2JqZWN0LCBldmVudC5tYXBDb29yZHMpO1xuXG4gICAgICBjb25zdCB1cGRhdGVkRGF0YSA9IHByb3BzLmRhdGFcbiAgICAgICAgLmFkZFBvc2l0aW9uKGZlYXR1cmVJbmRleCwgcG9zaXRpb25JbmRleGVzLCBpbnNlcnRNYXBDb29yZHMpXG4gICAgICAgIC5nZXRPYmplY3QoKTtcblxuICAgICAgcHJvcHMub25FZGl0KHtcbiAgICAgICAgZWRpdFR5cGU6IEVESVRfVFlQRS5BRERfUE9TSVRJT04sXG4gICAgICAgIHVwZGF0ZWREYXRhLFxuICAgICAgICBlZGl0Q29udGV4dDogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGZlYXR1cmVJbmRleCxcbiAgICAgICAgICAgIGVkaXRIYW5kbGVJbmRleDogaW5zZXJ0SW5kZXgsXG4gICAgICAgICAgICBzY3JlZW5Db29yZHM6IHByb3BzLnZpZXdwb3J0ICYmIHByb3BzLnZpZXdwb3J0LnByb2plY3QoaW5zZXJ0TWFwQ29vcmRzKSxcbiAgICAgICAgICAgIG1hcENvb3JkczogaW5zZXJ0TWFwQ29vcmRzXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgaGFuZGxlU3RvcERyYWdnaW5nKGV2ZW50OiBTdG9wRHJhZ2dpbmdFdmVudCwgcHJvcHM6IE1vZGVQcm9wczxGZWF0dXJlQ29sbGVjdGlvbj4pIHtcbiAgICAvLyByZXBsYWNlIHBvaW50XG4gICAgY29uc3QgcGlja2VkT2JqZWN0ID0gZXZlbnQucGlja3MgJiYgZXZlbnQucGlja3NbMF0gJiYgZXZlbnQucGlja3NbMF0ub2JqZWN0O1xuICAgIGlmICghcGlja2VkT2JqZWN0IHx8ICFpc051bWVyaWMocGlja2VkT2JqZWN0LmZlYXR1cmVJbmRleCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHBpY2tlZE9iamVjdC50eXBlKSB7XG4gICAgICBjYXNlIEVMRU1FTlRfVFlQRS5GRUFUVVJFOlxuICAgICAgY2FzZSBFTEVNRU5UX1RZUEUuRURJVF9IQU5ETEU6XG4gICAgICAgIHRoaXMuX2hhbmRsZURyYWdnaW5nKGV2ZW50LCBwcm9wcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gIH1cblxuICBfaGFuZGxlRHJhZ2dpbmcgPSAoXG4gICAgZXZlbnQ6IFBvaW50ZXJNb3ZlRXZlbnQgfCBTdG9wRHJhZ2dpbmdFdmVudCxcbiAgICBwcm9wczogTW9kZVByb3BzPEZlYXR1cmVDb2xsZWN0aW9uPlxuICApID0+IHtcbiAgICBjb25zdCB7IG9uRWRpdCB9ID0gcHJvcHM7XG4gICAgY29uc3Qgc2VsZWN0ZWRGZWF0dXJlID0gdGhpcy5nZXRTZWxlY3RlZEZlYXR1cmUocHJvcHMpO1xuICAgIC8vIG5vdGhpbmcgY2xpY2tlZFxuICAgIGNvbnN0IHsgaXNEcmFnZ2luZywgcG9pbnRlckRvd25QaWNrcywgc2NyZWVuQ29vcmRzIH0gPSBldmVudDtcbiAgICBjb25zdCB7IGxhc3RQb2ludGVyTW92ZUV2ZW50IH0gPSBwcm9wcztcblxuICAgIGNvbnN0IGNsaWNrZWRPYmplY3QgPSBwb2ludGVyRG93blBpY2tzICYmIHBvaW50ZXJEb3duUGlja3NbMF0gJiYgcG9pbnRlckRvd25QaWNrc1swXS5vYmplY3Q7XG4gICAgaWYgKCFjbGlja2VkT2JqZWN0IHx8ICFpc051bWVyaWMoY2xpY2tlZE9iamVjdC5mZWF0dXJlSW5kZXgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZWRpdEhhbmRsZUluZGV4ID0gY2xpY2tlZE9iamVjdC5pbmRleDtcblxuICAgIC8vIG5vdCBkcmFnZ2luZ1xuICAgIGxldCB1cGRhdGVkRGF0YSA9IG51bGw7XG4gICAgY29uc3QgZWRpdFR5cGUgPSBpc0RyYWdnaW5nID8gRURJVF9UWVBFLk1PVkVfUE9TSVRJT04gOiBFRElUX1RZUEUuRklOSVNIX01PVkVfUE9TSVRJT047XG5cbiAgICBzd2l0Y2ggKGNsaWNrZWRPYmplY3QudHlwZSkge1xuICAgICAgY2FzZSBFTEVNRU5UX1RZUEUuRkVBVFVSRTpcbiAgICAgIGNhc2UgRUxFTUVOVF9UWVBFLkZJTEw6XG4gICAgICBjYXNlIEVMRU1FTlRfVFlQRS5TRUdNRU5UOlxuICAgICAgICAvLyBkcmFnZ2luZyBmZWF0dXJlXG4gICAgICAgIGNvbnN0IGR4ID0gc2NyZWVuQ29vcmRzWzBdIC0gbGFzdFBvaW50ZXJNb3ZlRXZlbnQuc2NyZWVuQ29vcmRzWzBdO1xuICAgICAgICBjb25zdCBkeSA9IHNjcmVlbkNvb3Jkc1sxXSAtIGxhc3RQb2ludGVyTW92ZUV2ZW50LnNjcmVlbkNvb3Jkc1sxXTtcbiAgICAgICAgdXBkYXRlZERhdGEgPSB0aGlzLl91cGRhdGVGZWF0dXJlKHByb3BzLCAnZmVhdHVyZScsIHsgZHgsIGR5IH0pO1xuICAgICAgICBvbkVkaXQoe1xuICAgICAgICAgIGVkaXRUeXBlLFxuICAgICAgICAgIHVwZGF0ZWREYXRhLFxuICAgICAgICAgIGVkaXRDb250ZXh0OiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBFTEVNRU5UX1RZUEUuRURJVF9IQU5ETEU6XG4gICAgICAgIC8vIGRyYWdnaW5nIGVkaXRIYW5kbGVcbiAgICAgICAgLy8gZHJhZ2dpbmcgcmVjdGFuZ2xlIG9yIG90aGVyIHNoYXBlc1xuICAgICAgICBjb25zdCB1cGRhdGVUeXBlID1cbiAgICAgICAgICBzZWxlY3RlZEZlYXR1cmUucHJvcGVydGllcy5yZW5kZXJUeXBlID09PSBSRU5ERVJfVFlQRS5SRUNUQU5HTEVcbiAgICAgICAgICAgID8gJ3JlY3RhbmdsZSdcbiAgICAgICAgICAgIDogJ2VkaXRIYW5kbGUnO1xuICAgICAgICB1cGRhdGVkRGF0YSA9IHRoaXMuX3VwZGF0ZUZlYXR1cmUocHJvcHMsIHVwZGF0ZVR5cGUsIHtcbiAgICAgICAgICBlZGl0SGFuZGxlSW5kZXgsXG4gICAgICAgICAgbWFwQ29vcmRzOiBldmVudC5tYXBDb29yZHNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgb25FZGl0KHtcbiAgICAgICAgICBlZGl0VHlwZSxcbiAgICAgICAgICB1cGRhdGVkRGF0YSxcbiAgICAgICAgICBlZGl0Q29udGV4dDogbnVsbFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICB9O1xuXG4gIGhhbmRsZVBvaW50ZXJNb3ZlID0gKGV2ZW50OiBQb2ludGVyTW92ZUV2ZW50LCBwcm9wczogTW9kZVByb3BzPEZlYXR1cmVDb2xsZWN0aW9uPikgPT4ge1xuICAgIC8vIG5vIHNlbGVjdGVkIGZlYXR1cmVcbiAgICBjb25zdCBzZWxlY3RlZEZlYXR1cmUgPSB0aGlzLmdldFNlbGVjdGVkRmVhdHVyZShwcm9wcyk7XG4gICAgaWYgKCFzZWxlY3RlZEZlYXR1cmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWV2ZW50LmlzRHJhZ2dpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9oYW5kbGVEcmFnZ2luZyhldmVudCwgcHJvcHMpO1xuICB9O1xuXG4gIC8vIFRPRE8gLSByZWZhY3RvclxuICBfdXBkYXRlRmVhdHVyZSA9IChwcm9wczogTW9kZVByb3BzPEZlYXR1cmVDb2xsZWN0aW9uPiwgdHlwZTogc3RyaW5nLCBvcHRpb25zOiBhbnkgPSB7fSkgPT4ge1xuICAgIGNvbnN0IHsgZGF0YSwgc2VsZWN0ZWRJbmRleGVzLCB2aWV3cG9ydCB9ID0gcHJvcHM7XG5cbiAgICBjb25zdCBmZWF0dXJlSW5kZXggPSBzZWxlY3RlZEluZGV4ZXMgJiYgc2VsZWN0ZWRJbmRleGVzWzBdO1xuICAgIGNvbnN0IGZlYXR1cmUgPSB0aGlzLmdldFNlbGVjdGVkRmVhdHVyZShwcm9wcywgZmVhdHVyZUluZGV4KTtcblxuICAgIGxldCBnZW9tZXRyeSA9IG51bGw7XG4gICAgY29uc3QgY29vcmRpbmF0ZXMgPSBnZXRGZWF0dXJlQ29vcmRpbmF0ZXMoZmVhdHVyZSk7XG4gICAgaWYgKCFjb29yZGluYXRlcykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgbGV0IG5ld0Nvb3JkaW5hdGVzID0gWy4uLmNvb3JkaW5hdGVzXTtcblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnZWRpdEhhbmRsZSc6XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uSW5kZXhlcyA9XG4gICAgICAgICAgZmVhdHVyZS5nZW9tZXRyeS50eXBlID09PSBHRU9KU09OX1RZUEUuUE9MWUdPTlxuICAgICAgICAgICAgPyBbMCwgb3B0aW9ucy5lZGl0SGFuZGxlSW5kZXhdXG4gICAgICAgICAgICA6IFtvcHRpb25zLmVkaXRIYW5kbGVJbmRleF07XG5cbiAgICAgICAgcmV0dXJuIGRhdGEucmVwbGFjZVBvc2l0aW9uKGZlYXR1cmVJbmRleCwgcG9zaXRpb25JbmRleGVzLCBvcHRpb25zLm1hcENvb3JkcykuZ2V0T2JqZWN0KCk7XG5cbiAgICAgIGNhc2UgJ2ZlYXR1cmUnOlxuICAgICAgICBjb25zdCB7IGR4LCBkeSB9ID0gb3B0aW9ucztcbiAgICAgICAgbmV3Q29vcmRpbmF0ZXMgPSBuZXdDb29yZGluYXRlc1xuICAgICAgICAgIC5tYXAobWFwQ29vcmRzID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBpeGVscyA9IHZpZXdwb3J0ICYmIHZpZXdwb3J0LnByb2plY3QobWFwQ29vcmRzKTtcbiAgICAgICAgICAgIGlmIChwaXhlbHMpIHtcbiAgICAgICAgICAgICAgcGl4ZWxzWzBdICs9IGR4O1xuICAgICAgICAgICAgICBwaXhlbHNbMV0gKz0gZHk7XG4gICAgICAgICAgICAgIHJldHVybiB2aWV3cG9ydCAmJiB2aWV3cG9ydC51bnByb2plY3QocGl4ZWxzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLmZpbHRlcihCb29sZWFuKTtcblxuICAgICAgICBnZW9tZXRyeSA9IHtcbiAgICAgICAgICB0eXBlOiBmZWF0dXJlLmdlb21ldHJ5LnR5cGUsXG4gICAgICAgICAgY29vcmRpbmF0ZXM6XG4gICAgICAgICAgICBmZWF0dXJlLmdlb21ldHJ5LnR5cGUgPT09IEdFT0pTT05fVFlQRS5QT0xZR09OID8gW25ld0Nvb3JkaW5hdGVzXSA6IG5ld0Nvb3JkaW5hdGVzXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGRhdGEucmVwbGFjZUdlb21ldHJ5KGZlYXR1cmVJbmRleCwgZ2VvbWV0cnkpLmdldE9iamVjdCgpO1xuXG4gICAgICBjYXNlICdyZWN0YW5nbGUnOlxuICAgICAgICAvLyBtb3ZlZCBlZGl0SGFuZGxlSW5kZXggYW5kIGRlc3RpbmF0aW9uIG1hcENvb3Jkc1xuICAgICAgICBuZXdDb29yZGluYXRlcyA9IHVwZGF0ZVJlY3RhbmdsZVBvc2l0aW9uKFxuICAgICAgICAgIGZlYXR1cmUsXG4gICAgICAgICAgb3B0aW9ucy5lZGl0SGFuZGxlSW5kZXgsXG4gICAgICAgICAgb3B0aW9ucy5tYXBDb29yZHNcbiAgICAgICAgKTtcblxuICAgICAgICBnZW9tZXRyeSA9IHtcbiAgICAgICAgICB0eXBlOiBHRU9KU09OX1RZUEUuUE9MWUdPTixcbiAgICAgICAgICBjb29yZGluYXRlczogbmV3Q29vcmRpbmF0ZXNcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gZGF0YS5yZXBsYWNlR2VvbWV0cnkoZmVhdHVyZUluZGV4LCBnZW9tZXRyeSkuZ2V0T2JqZWN0KCk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBkYXRhICYmIGRhdGEuZ2V0T2JqZWN0KCk7XG4gICAgfVxuICB9O1xuXG4gIF9nZXRQb2ludE9uU2VnbWVudChmZWF0dXJlOiBGZWF0dXJlLCBwaWNrZWRPYmplY3Q6IGFueSwgcGlja2VkTWFwQ29vcmRzOiBQb3NpdGlvbikge1xuICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gZ2V0RmVhdHVyZUNvb3JkaW5hdGVzKGZlYXR1cmUpO1xuICAgIGlmICghY29vcmRpbmF0ZXMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzcmNWZXJ0ZXhJbmRleCA9IHBpY2tlZE9iamVjdC5pbmRleDtcbiAgICBjb25zdCB0YXJnZXRWZXJ0ZXhJbmRleCA9IHBpY2tlZE9iamVjdC5pbmRleCArIDE7XG4gICAgcmV0dXJuIGZpbmRDbG9zZXN0UG9pbnRPbkxpbmVTZWdtZW50KFxuICAgICAgY29vcmRpbmF0ZXNbc3JjVmVydGV4SW5kZXhdLFxuICAgICAgY29vcmRpbmF0ZXNbdGFyZ2V0VmVydGV4SW5kZXhdLFxuICAgICAgcGlja2VkTWFwQ29vcmRzXG4gICAgKTtcbiAgfVxuXG4gIF9nZXRDdXJzb3JFZGl0SGFuZGxlID0gKGV2ZW50OiBQb2ludGVyTW92ZUV2ZW50LCBmZWF0dXJlOiBGZWF0dXJlKSA9PiB7XG4gICAgY29uc3QgeyBpc0RyYWdnaW5nLCBwaWNrcyB9ID0gZXZlbnQ7XG4gICAgLy8gaWYgbm90IHBpY2sgc2VnbWVudFxuICAgIGNvbnN0IHBpY2tlZE9iamVjdCA9IHBpY2tzICYmIHBpY2tzWzBdICYmIHBpY2tzWzBdLm9iamVjdDtcbiAgICBpZiAoXG4gICAgICAhcGlja2VkT2JqZWN0IHx8XG4gICAgICAhaXNOdW1lcmljKHBpY2tlZE9iamVjdC5mZWF0dXJlSW5kZXgpIHx8XG4gICAgICBwaWNrZWRPYmplY3QudHlwZSAhPT0gRUxFTUVOVF9UWVBFLlNFR01FTlRcbiAgICApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIGlmIGRyYWdnaW5nIG9yIGZlYXR1cmUgaXMgbmVpdGhlciBwb2x5Z29uIG5vciBsaW5lIHN0cmluZ1xuICAgIGlmIChcbiAgICAgIGlzRHJhZ2dpbmcgfHxcbiAgICAgIChmZWF0dXJlLnByb3BlcnRpZXMucmVuZGVyVHlwZSAhPT0gR0VPSlNPTl9UWVBFLlBPTFlHT04gJiZcbiAgICAgICAgZmVhdHVyZS5wcm9wZXJ0aWVzLnJlbmRlclR5cGUgIT09IEdFT0pTT05fVFlQRS5MSU5FX1NUUklORylcbiAgICApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGluc2VydE1hcENvb3JkcyA9IHRoaXMuX2dldFBvaW50T25TZWdtZW50KGZlYXR1cmUsIHBpY2tlZE9iamVjdCwgZXZlbnQubWFwQ29vcmRzKTtcblxuICAgIGlmICghaW5zZXJ0TWFwQ29vcmRzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ0ZlYXR1cmUnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBndWlkZVR5cGU6IEdVSURFX1RZUEUuQ1VSU09SX0VESVRfSEFORExFLFxuICAgICAgICByZW5kZXJUeXBlOiBmZWF0dXJlLnByb3BlcnRpZXMucmVuZGVyVHlwZSxcbiAgICAgICAgcG9zaXRpb25JbmRleGVzOiBbbnVsbF1cbiAgICAgIH0sXG4gICAgICBnZW9tZXRyeToge1xuICAgICAgICB0eXBlOiBHRU9KU09OX1RZUEUuUE9JTlQsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBbaW5zZXJ0TWFwQ29vcmRzXVxuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgZ2V0R3VpZGVzID0gKHByb3BzOiBNb2RlUHJvcHM8RmVhdHVyZUNvbGxlY3Rpb24+KSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0ZWRGZWF0dXJlID0gdGhpcy5nZXRTZWxlY3RlZEZlYXR1cmUocHJvcHMpO1xuICAgIGNvbnN0IHNlbGVjdGVkRmVhdHVyZUluZGV4ID0gcHJvcHMuc2VsZWN0ZWRJbmRleGVzICYmIHByb3BzLnNlbGVjdGVkSW5kZXhlc1swXTtcblxuICAgIGlmICghc2VsZWN0ZWRGZWF0dXJlIHx8IHNlbGVjdGVkRmVhdHVyZS5nZW9tZXRyeS50eXBlID09PSBHRU9KU09OX1RZUEUuUE9JTlQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGV2ZW50ID0gcHJvcHMubGFzdFBvaW50ZXJNb3ZlRXZlbnQ7XG5cbiAgICAvLyBmZWF0dXJlIGVkaXRIYW5kbGVzXG4gICAgY29uc3QgZWRpdEhhbmRsZXMgPSB0aGlzLmdldEVkaXRIYW5kbGVzRnJvbUZlYXR1cmUoc2VsZWN0ZWRGZWF0dXJlLCBzZWxlY3RlZEZlYXR1cmVJbmRleCkgfHwgW107XG5cbiAgICAvLyBjdXJzb3IgZWRpdEhhbmRsZVxuICAgIGNvbnN0IGN1cnNvckVkaXRIYW5kbGUgPSB0aGlzLl9nZXRDdXJzb3JFZGl0SGFuZGxlKGV2ZW50LCBzZWxlY3RlZEZlYXR1cmUpO1xuICAgIGlmIChjdXJzb3JFZGl0SGFuZGxlKSB7XG4gICAgICBlZGl0SGFuZGxlcy5wdXNoKHRoaXMuX2dldEN1cnNvckVkaXRIYW5kbGUoZXZlbnQsIHNlbGVjdGVkRmVhdHVyZSkpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBlZGl0SGFuZGxlczogZWRpdEhhbmRsZXMubGVuZ3RoID8gZWRpdEhhbmRsZXMgOiBudWxsXG4gICAgfTtcbiAgfTtcbn1cbiJdfQ==