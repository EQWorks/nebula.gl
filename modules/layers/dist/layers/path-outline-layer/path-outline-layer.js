"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _keplerOutdatedDeck = require("kepler-outdated-deck.gl-layers");

var _constants = _interopRequireDefault(require("@luma.gl/constants"));

var _core = require("@luma.gl/core");

var _outline = _interopRequireDefault(require("../../shaderlib/outline/outline"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// TODO - this should be built into assembleShaders
function injectShaderCode(_ref) {
  var source = _ref.source,
      _ref$code = _ref.code,
      code = _ref$code === void 0 ? '' : _ref$code;
  var INJECT_CODE = /}[^{}]*$/;
  return source.replace(INJECT_CODE, code.concat('\n}\n'));
}

var VS_CODE = "  outline_setUV(gl_Position);\n  outline_setZLevel(instanceZLevel);\n";
var FS_CODE = "  gl_FragColor = outline_filterColor(gl_FragColor);\n";
var defaultProps = {
  getZLevel: {
    type: 'accessor',
    value: 0
  }
};

class PathOutlineLayer extends _keplerOutdatedDeck.PathLayer {
  // Override getShaders to inject the outline module
  getShaders() {
    var shaders = super.getShaders();
    return Object.assign({}, shaders, {
      modules: shaders.modules.concat([_outline.default]),
      vs: injectShaderCode({
        source: shaders.vs,
        code: VS_CODE
      }),
      fs: injectShaderCode({
        source: shaders.fs,
        code: FS_CODE
      })
    });
  }

  initializeState(context) {
    super.initializeState(context); // Create an outline "shadow" map
    // TODO - we should create a single outlineMap for all layers

    this.setState({
      outlineFramebuffer: new _core.Framebuffer(context.gl),
      dummyTexture: new _core.Texture2D(context.gl)
    }); // Create an attribute manager

    this.state.attributeManager.addInstanced({
      instanceZLevel: {
        size: 1,
        type: _constants.default.UNSIGNED_BYTE,
        update: this.calculateZLevels,
        accessor: 'getZLevel'
      }
    });
  } // Override draw to add render module


  draw(_ref2) {
    var _ref2$moduleParameter = _ref2.moduleParameters,
        moduleParameters = _ref2$moduleParameter === void 0 ? {} : _ref2$moduleParameter,
        parameters = _ref2.parameters,
        uniforms = _ref2.uniforms,
        context = _ref2.context;
    // Need to calculate same uniforms as base layer
    var _this$props = this.props,
        rounded = _this$props.rounded,
        miterLimit = _this$props.miterLimit,
        widthScale = _this$props.widthScale,
        widthMinPixels = _this$props.widthMinPixels,
        widthMaxPixels = _this$props.widthMaxPixels,
        dashJustified = _this$props.dashJustified;
    uniforms = Object.assign({}, uniforms, {
      jointType: Number(rounded),
      alignMode: Number(dashJustified),
      widthScale: widthScale,
      miterLimit: miterLimit,
      widthMinPixels: widthMinPixels,
      widthMaxPixels: widthMaxPixels
    }); // Render the outline shadowmap (based on segment z orders)

    var _this$state = this.state,
        outlineFramebuffer = _this$state.outlineFramebuffer,
        dummyTexture = _this$state.dummyTexture;
    outlineFramebuffer.resize();
    outlineFramebuffer.clear({
      color: true,
      depth: true
    });
    this.state.model.updateModuleSettings({
      outlineEnabled: true,
      outlineRenderShadowmap: true,
      outlineShadowmap: dummyTexture
    });
    this.state.model.draw({
      uniforms: Object.assign({}, uniforms, {
        jointType: 0,
        widthScale: this.props.widthScale * 1.3
      }),
      parameters: {
        depthTest: false,
        // Biggest value needs to go into buffer
        blendEquation: _constants.default.MAX
      },
      framebuffer: outlineFramebuffer
    }); // Now use the outline shadowmap to render the lines (with outlines)

    this.state.model.updateModuleSettings({
      outlineEnabled: true,
      outlineRenderShadowmap: false,
      outlineShadowmap: outlineFramebuffer
    });
    this.state.model.draw({
      uniforms: Object.assign({}, uniforms, {
        jointType: Number(rounded),
        widthScale: this.props.widthScale
      }),
      parameters: {
        depthTest: false
      }
    });
  }

  calculateZLevels(attribute) {
    var getZLevel = this.props.getZLevel;
    var pathTesselator = this.state.pathTesselator;
    attribute.value = pathTesselator._updateAttribute({
      target: attribute.value,
      size: 1,
      getValue: function getValue(object, index) {
        return [getZLevel(object, index) || 0];
      }
    });
  }

}

exports.default = PathOutlineLayer;
PathOutlineLayer.layerName = 'PathOutlineLayer';
PathOutlineLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9sYXllcnMvcGF0aC1vdXRsaW5lLWxheWVyL3BhdGgtb3V0bGluZS1sYXllci5qcyJdLCJuYW1lcyI6WyJpbmplY3RTaGFkZXJDb2RlIiwic291cmNlIiwiY29kZSIsIklOSkVDVF9DT0RFIiwicmVwbGFjZSIsImNvbmNhdCIsIlZTX0NPREUiLCJGU19DT0RFIiwiZGVmYXVsdFByb3BzIiwiZ2V0WkxldmVsIiwidHlwZSIsInZhbHVlIiwiUGF0aE91dGxpbmVMYXllciIsIlBhdGhMYXllciIsImdldFNoYWRlcnMiLCJzaGFkZXJzIiwiT2JqZWN0IiwiYXNzaWduIiwibW9kdWxlcyIsIm91dGxpbmUiLCJ2cyIsImZzIiwiaW5pdGlhbGl6ZVN0YXRlIiwiY29udGV4dCIsInNldFN0YXRlIiwib3V0bGluZUZyYW1lYnVmZmVyIiwiRnJhbWVidWZmZXIiLCJnbCIsImR1bW15VGV4dHVyZSIsIlRleHR1cmUyRCIsInN0YXRlIiwiYXR0cmlidXRlTWFuYWdlciIsImFkZEluc3RhbmNlZCIsImluc3RhbmNlWkxldmVsIiwic2l6ZSIsIkdMIiwiVU5TSUdORURfQllURSIsInVwZGF0ZSIsImNhbGN1bGF0ZVpMZXZlbHMiLCJhY2Nlc3NvciIsImRyYXciLCJtb2R1bGVQYXJhbWV0ZXJzIiwicGFyYW1ldGVycyIsInVuaWZvcm1zIiwicHJvcHMiLCJyb3VuZGVkIiwibWl0ZXJMaW1pdCIsIndpZHRoU2NhbGUiLCJ3aWR0aE1pblBpeGVscyIsIndpZHRoTWF4UGl4ZWxzIiwiZGFzaEp1c3RpZmllZCIsImpvaW50VHlwZSIsIk51bWJlciIsImFsaWduTW9kZSIsInJlc2l6ZSIsImNsZWFyIiwiY29sb3IiLCJkZXB0aCIsIm1vZGVsIiwidXBkYXRlTW9kdWxlU2V0dGluZ3MiLCJvdXRsaW5lRW5hYmxlZCIsIm91dGxpbmVSZW5kZXJTaGFkb3dtYXAiLCJvdXRsaW5lU2hhZG93bWFwIiwiZGVwdGhUZXN0IiwiYmxlbmRFcXVhdGlvbiIsIk1BWCIsImZyYW1lYnVmZmVyIiwiYXR0cmlidXRlIiwicGF0aFRlc3NlbGF0b3IiLCJfdXBkYXRlQXR0cmlidXRlIiwidGFyZ2V0IiwiZ2V0VmFsdWUiLCJvYmplY3QiLCJpbmRleCIsImxheWVyTmFtZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOzs7O0FBRUE7QUFDQSxTQUFTQSxnQkFBVCxPQUFpRDtBQUFBLE1BQXJCQyxNQUFxQixRQUFyQkEsTUFBcUI7QUFBQSx1QkFBYkMsSUFBYTtBQUFBLE1BQWJBLElBQWEsMEJBQU4sRUFBTTtBQUMvQyxNQUFNQyxXQUFXLEdBQUcsVUFBcEI7QUFDQSxTQUFPRixNQUFNLENBQUNHLE9BQVAsQ0FBZUQsV0FBZixFQUE0QkQsSUFBSSxDQUFDRyxNQUFMLENBQVksT0FBWixDQUE1QixDQUFQO0FBQ0Q7O0FBRUQsSUFBTUMsT0FBTywwRUFBYjtBQUtBLElBQU1DLE9BQU8sMERBQWI7QUFJQSxJQUFNQyxZQUFZLEdBQUc7QUFDbkJDLEVBQUFBLFNBQVMsRUFBRTtBQUFFQyxJQUFBQSxJQUFJLEVBQUUsVUFBUjtBQUFvQkMsSUFBQUEsS0FBSyxFQUFFO0FBQTNCO0FBRFEsQ0FBckI7O0FBSWUsTUFBTUMsZ0JBQU4sU0FBK0JDLDZCQUEvQixDQUF5QztBQUN0RDtBQUNBQyxFQUFBQSxVQUFVLEdBQUc7QUFDWCxRQUFNQyxPQUFPLEdBQUcsTUFBTUQsVUFBTixFQUFoQjtBQUNBLFdBQU9FLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjLEVBQWQsRUFBa0JGLE9BQWxCLEVBQTJCO0FBQ2hDRyxNQUFBQSxPQUFPLEVBQUVILE9BQU8sQ0FBQ0csT0FBUixDQUFnQmIsTUFBaEIsQ0FBdUIsQ0FBQ2MsZ0JBQUQsQ0FBdkIsQ0FEdUI7QUFFaENDLE1BQUFBLEVBQUUsRUFBRXBCLGdCQUFnQixDQUFDO0FBQUVDLFFBQUFBLE1BQU0sRUFBRWMsT0FBTyxDQUFDSyxFQUFsQjtBQUFzQmxCLFFBQUFBLElBQUksRUFBRUk7QUFBNUIsT0FBRCxDQUZZO0FBR2hDZSxNQUFBQSxFQUFFLEVBQUVyQixnQkFBZ0IsQ0FBQztBQUFFQyxRQUFBQSxNQUFNLEVBQUVjLE9BQU8sQ0FBQ00sRUFBbEI7QUFBc0JuQixRQUFBQSxJQUFJLEVBQUVLO0FBQTVCLE9BQUQ7QUFIWSxLQUEzQixDQUFQO0FBS0Q7O0FBRURlLEVBQUFBLGVBQWUsQ0FBQ0MsT0FBRCxFQUFVO0FBQ3ZCLFVBQU1ELGVBQU4sQ0FBc0JDLE9BQXRCLEVBRHVCLENBR3ZCO0FBQ0E7O0FBQ0EsU0FBS0MsUUFBTCxDQUFjO0FBQ1pDLE1BQUFBLGtCQUFrQixFQUFFLElBQUlDLGlCQUFKLENBQWdCSCxPQUFPLENBQUNJLEVBQXhCLENBRFI7QUFFWkMsTUFBQUEsWUFBWSxFQUFFLElBQUlDLGVBQUosQ0FBY04sT0FBTyxDQUFDSSxFQUF0QjtBQUZGLEtBQWQsRUFMdUIsQ0FVdkI7O0FBQ0EsU0FBS0csS0FBTCxDQUFXQyxnQkFBWCxDQUE0QkMsWUFBNUIsQ0FBeUM7QUFDdkNDLE1BQUFBLGNBQWMsRUFBRTtBQUNkQyxRQUFBQSxJQUFJLEVBQUUsQ0FEUTtBQUVkeEIsUUFBQUEsSUFBSSxFQUFFeUIsbUJBQUdDLGFBRks7QUFHZEMsUUFBQUEsTUFBTSxFQUFFLEtBQUtDLGdCQUhDO0FBSWRDLFFBQUFBLFFBQVEsRUFBRTtBQUpJO0FBRHVCLEtBQXpDO0FBUUQsR0E5QnFELENBZ0N0RDs7O0FBQ0FDLEVBQUFBLElBQUksUUFBMkQ7QUFBQSxzQ0FBeERDLGdCQUF3RDtBQUFBLFFBQXhEQSxnQkFBd0Qsc0NBQXJDLEVBQXFDO0FBQUEsUUFBakNDLFVBQWlDLFNBQWpDQSxVQUFpQztBQUFBLFFBQXJCQyxRQUFxQixTQUFyQkEsUUFBcUI7QUFBQSxRQUFYcEIsT0FBVyxTQUFYQSxPQUFXO0FBQzdEO0FBRDZELHNCQVN6RCxLQUFLcUIsS0FUb0Q7QUFBQSxRQUczREMsT0FIMkQsZUFHM0RBLE9BSDJEO0FBQUEsUUFJM0RDLFVBSjJELGVBSTNEQSxVQUoyRDtBQUFBLFFBSzNEQyxVQUwyRCxlQUszREEsVUFMMkQ7QUFBQSxRQU0zREMsY0FOMkQsZUFNM0RBLGNBTjJEO0FBQUEsUUFPM0RDLGNBUDJELGVBTzNEQSxjQVAyRDtBQUFBLFFBUTNEQyxhQVIyRCxlQVEzREEsYUFSMkQ7QUFXN0RQLElBQUFBLFFBQVEsR0FBRzNCLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjLEVBQWQsRUFBa0IwQixRQUFsQixFQUE0QjtBQUNyQ1EsTUFBQUEsU0FBUyxFQUFFQyxNQUFNLENBQUNQLE9BQUQsQ0FEb0I7QUFFckNRLE1BQUFBLFNBQVMsRUFBRUQsTUFBTSxDQUFDRixhQUFELENBRm9CO0FBR3JDSCxNQUFBQSxVQUFVLEVBQVZBLFVBSHFDO0FBSXJDRCxNQUFBQSxVQUFVLEVBQVZBLFVBSnFDO0FBS3JDRSxNQUFBQSxjQUFjLEVBQWRBLGNBTHFDO0FBTXJDQyxNQUFBQSxjQUFjLEVBQWRBO0FBTnFDLEtBQTVCLENBQVgsQ0FYNkQsQ0FvQjdEOztBQXBCNkQsc0JBcUJoQixLQUFLbkIsS0FyQlc7QUFBQSxRQXFCckRMLGtCQXJCcUQsZUFxQnJEQSxrQkFyQnFEO0FBQUEsUUFxQmpDRyxZQXJCaUMsZUFxQmpDQSxZQXJCaUM7QUFzQjdESCxJQUFBQSxrQkFBa0IsQ0FBQzZCLE1BQW5CO0FBQ0E3QixJQUFBQSxrQkFBa0IsQ0FBQzhCLEtBQW5CLENBQXlCO0FBQUVDLE1BQUFBLEtBQUssRUFBRSxJQUFUO0FBQWVDLE1BQUFBLEtBQUssRUFBRTtBQUF0QixLQUF6QjtBQUVBLFNBQUszQixLQUFMLENBQVc0QixLQUFYLENBQWlCQyxvQkFBakIsQ0FBc0M7QUFDcENDLE1BQUFBLGNBQWMsRUFBRSxJQURvQjtBQUVwQ0MsTUFBQUEsc0JBQXNCLEVBQUUsSUFGWTtBQUdwQ0MsTUFBQUEsZ0JBQWdCLEVBQUVsQztBQUhrQixLQUF0QztBQU1BLFNBQUtFLEtBQUwsQ0FBVzRCLEtBQVgsQ0FBaUJsQixJQUFqQixDQUFzQjtBQUNwQkcsTUFBQUEsUUFBUSxFQUFFM0IsTUFBTSxDQUFDQyxNQUFQLENBQWMsRUFBZCxFQUFrQjBCLFFBQWxCLEVBQTRCO0FBQ3BDUSxRQUFBQSxTQUFTLEVBQUUsQ0FEeUI7QUFFcENKLFFBQUFBLFVBQVUsRUFBRSxLQUFLSCxLQUFMLENBQVdHLFVBQVgsR0FBd0I7QUFGQSxPQUE1QixDQURVO0FBS3BCTCxNQUFBQSxVQUFVLEVBQUU7QUFDVnFCLFFBQUFBLFNBQVMsRUFBRSxLQUREO0FBRVY7QUFDQUMsUUFBQUEsYUFBYSxFQUFFN0IsbUJBQUc4QjtBQUhSLE9BTFE7QUFVcEJDLE1BQUFBLFdBQVcsRUFBRXpDO0FBVk8sS0FBdEIsRUEvQjZELENBNEM3RDs7QUFDQSxTQUFLSyxLQUFMLENBQVc0QixLQUFYLENBQWlCQyxvQkFBakIsQ0FBc0M7QUFDcENDLE1BQUFBLGNBQWMsRUFBRSxJQURvQjtBQUVwQ0MsTUFBQUEsc0JBQXNCLEVBQUUsS0FGWTtBQUdwQ0MsTUFBQUEsZ0JBQWdCLEVBQUVyQztBQUhrQixLQUF0QztBQUtBLFNBQUtLLEtBQUwsQ0FBVzRCLEtBQVgsQ0FBaUJsQixJQUFqQixDQUFzQjtBQUNwQkcsTUFBQUEsUUFBUSxFQUFFM0IsTUFBTSxDQUFDQyxNQUFQLENBQWMsRUFBZCxFQUFrQjBCLFFBQWxCLEVBQTRCO0FBQ3BDUSxRQUFBQSxTQUFTLEVBQUVDLE1BQU0sQ0FBQ1AsT0FBRCxDQURtQjtBQUVwQ0UsUUFBQUEsVUFBVSxFQUFFLEtBQUtILEtBQUwsQ0FBV0c7QUFGYSxPQUE1QixDQURVO0FBS3BCTCxNQUFBQSxVQUFVLEVBQUU7QUFDVnFCLFFBQUFBLFNBQVMsRUFBRTtBQUREO0FBTFEsS0FBdEI7QUFTRDs7QUFFRHpCLEVBQUFBLGdCQUFnQixDQUFDNkIsU0FBRCxFQUFZO0FBQUEsUUFDbEIxRCxTQURrQixHQUNKLEtBQUttQyxLQURELENBQ2xCbkMsU0FEa0I7QUFBQSxRQUVsQjJELGNBRmtCLEdBRUMsS0FBS3RDLEtBRk4sQ0FFbEJzQyxjQUZrQjtBQUkxQkQsSUFBQUEsU0FBUyxDQUFDeEQsS0FBVixHQUFrQnlELGNBQWMsQ0FBQ0MsZ0JBQWYsQ0FBZ0M7QUFDaERDLE1BQUFBLE1BQU0sRUFBRUgsU0FBUyxDQUFDeEQsS0FEOEI7QUFFaER1QixNQUFBQSxJQUFJLEVBQUUsQ0FGMEM7QUFHaERxQyxNQUFBQSxRQUFRLEVBQUUsa0JBQUNDLE1BQUQsRUFBU0MsS0FBVDtBQUFBLGVBQW1CLENBQUNoRSxTQUFTLENBQUMrRCxNQUFELEVBQVNDLEtBQVQsQ0FBVCxJQUE0QixDQUE3QixDQUFuQjtBQUFBO0FBSHNDLEtBQWhDLENBQWxCO0FBS0Q7O0FBdkdxRDs7O0FBMEd4RDdELGdCQUFnQixDQUFDOEQsU0FBakIsR0FBNkIsa0JBQTdCO0FBQ0E5RCxnQkFBZ0IsQ0FBQ0osWUFBakIsR0FBZ0NBLFlBQWhDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGF0aExheWVyIH0gZnJvbSAna2VwbGVyLW91dGRhdGVkLWRlY2suZ2wtbGF5ZXJzJztcbmltcG9ydCBHTCBmcm9tICdAbHVtYS5nbC9jb25zdGFudHMnO1xuaW1wb3J0IHsgRnJhbWVidWZmZXIsIFRleHR1cmUyRCB9IGZyb20gJ0BsdW1hLmdsL2NvcmUnO1xuaW1wb3J0IG91dGxpbmUgZnJvbSAnLi4vLi4vc2hhZGVybGliL291dGxpbmUvb3V0bGluZSc7XG5cbi8vIFRPRE8gLSB0aGlzIHNob3VsZCBiZSBidWlsdCBpbnRvIGFzc2VtYmxlU2hhZGVyc1xuZnVuY3Rpb24gaW5qZWN0U2hhZGVyQ29kZSh7IHNvdXJjZSwgY29kZSA9ICcnIH0pIHtcbiAgY29uc3QgSU5KRUNUX0NPREUgPSAvfVtee31dKiQvO1xuICByZXR1cm4gc291cmNlLnJlcGxhY2UoSU5KRUNUX0NPREUsIGNvZGUuY29uY2F0KCdcXG59XFxuJykpO1xufVxuXG5jb25zdCBWU19DT0RFID0gYFxcXG4gIG91dGxpbmVfc2V0VVYoZ2xfUG9zaXRpb24pO1xuICBvdXRsaW5lX3NldFpMZXZlbChpbnN0YW5jZVpMZXZlbCk7XG5gO1xuXG5jb25zdCBGU19DT0RFID0gYFxcXG4gIGdsX0ZyYWdDb2xvciA9IG91dGxpbmVfZmlsdGVyQ29sb3IoZ2xfRnJhZ0NvbG9yKTtcbmA7XG5cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgZ2V0WkxldmVsOiB7IHR5cGU6ICdhY2Nlc3NvcicsIHZhbHVlOiAwIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhdGhPdXRsaW5lTGF5ZXIgZXh0ZW5kcyBQYXRoTGF5ZXIge1xuICAvLyBPdmVycmlkZSBnZXRTaGFkZXJzIHRvIGluamVjdCB0aGUgb3V0bGluZSBtb2R1bGVcbiAgZ2V0U2hhZGVycygpIHtcbiAgICBjb25zdCBzaGFkZXJzID0gc3VwZXIuZ2V0U2hhZGVycygpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzaGFkZXJzLCB7XG4gICAgICBtb2R1bGVzOiBzaGFkZXJzLm1vZHVsZXMuY29uY2F0KFtvdXRsaW5lXSksXG4gICAgICB2czogaW5qZWN0U2hhZGVyQ29kZSh7IHNvdXJjZTogc2hhZGVycy52cywgY29kZTogVlNfQ09ERSB9KSxcbiAgICAgIGZzOiBpbmplY3RTaGFkZXJDb2RlKHsgc291cmNlOiBzaGFkZXJzLmZzLCBjb2RlOiBGU19DT0RFIH0pXG4gICAgfSk7XG4gIH1cblxuICBpbml0aWFsaXplU3RhdGUoY29udGV4dCkge1xuICAgIHN1cGVyLmluaXRpYWxpemVTdGF0ZShjb250ZXh0KTtcblxuICAgIC8vIENyZWF0ZSBhbiBvdXRsaW5lIFwic2hhZG93XCIgbWFwXG4gICAgLy8gVE9ETyAtIHdlIHNob3VsZCBjcmVhdGUgYSBzaW5nbGUgb3V0bGluZU1hcCBmb3IgYWxsIGxheWVyc1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgb3V0bGluZUZyYW1lYnVmZmVyOiBuZXcgRnJhbWVidWZmZXIoY29udGV4dC5nbCksXG4gICAgICBkdW1teVRleHR1cmU6IG5ldyBUZXh0dXJlMkQoY29udGV4dC5nbClcbiAgICB9KTtcblxuICAgIC8vIENyZWF0ZSBhbiBhdHRyaWJ1dGUgbWFuYWdlclxuICAgIHRoaXMuc3RhdGUuYXR0cmlidXRlTWFuYWdlci5hZGRJbnN0YW5jZWQoe1xuICAgICAgaW5zdGFuY2VaTGV2ZWw6IHtcbiAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgdHlwZTogR0wuVU5TSUdORURfQllURSxcbiAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZVpMZXZlbHMsXG4gICAgICAgIGFjY2Vzc29yOiAnZ2V0WkxldmVsJ1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gT3ZlcnJpZGUgZHJhdyB0byBhZGQgcmVuZGVyIG1vZHVsZVxuICBkcmF3KHsgbW9kdWxlUGFyYW1ldGVycyA9IHt9LCBwYXJhbWV0ZXJzLCB1bmlmb3JtcywgY29udGV4dCB9KSB7XG4gICAgLy8gTmVlZCB0byBjYWxjdWxhdGUgc2FtZSB1bmlmb3JtcyBhcyBiYXNlIGxheWVyXG4gICAgY29uc3Qge1xuICAgICAgcm91bmRlZCxcbiAgICAgIG1pdGVyTGltaXQsXG4gICAgICB3aWR0aFNjYWxlLFxuICAgICAgd2lkdGhNaW5QaXhlbHMsXG4gICAgICB3aWR0aE1heFBpeGVscyxcbiAgICAgIGRhc2hKdXN0aWZpZWRcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIHVuaWZvcm1zID0gT2JqZWN0LmFzc2lnbih7fSwgdW5pZm9ybXMsIHtcbiAgICAgIGpvaW50VHlwZTogTnVtYmVyKHJvdW5kZWQpLFxuICAgICAgYWxpZ25Nb2RlOiBOdW1iZXIoZGFzaEp1c3RpZmllZCksXG4gICAgICB3aWR0aFNjYWxlLFxuICAgICAgbWl0ZXJMaW1pdCxcbiAgICAgIHdpZHRoTWluUGl4ZWxzLFxuICAgICAgd2lkdGhNYXhQaXhlbHNcbiAgICB9KTtcblxuICAgIC8vIFJlbmRlciB0aGUgb3V0bGluZSBzaGFkb3dtYXAgKGJhc2VkIG9uIHNlZ21lbnQgeiBvcmRlcnMpXG4gICAgY29uc3QgeyBvdXRsaW5lRnJhbWVidWZmZXIsIGR1bW15VGV4dHVyZSB9ID0gdGhpcy5zdGF0ZTtcbiAgICBvdXRsaW5lRnJhbWVidWZmZXIucmVzaXplKCk7XG4gICAgb3V0bGluZUZyYW1lYnVmZmVyLmNsZWFyKHsgY29sb3I6IHRydWUsIGRlcHRoOiB0cnVlIH0pO1xuXG4gICAgdGhpcy5zdGF0ZS5tb2RlbC51cGRhdGVNb2R1bGVTZXR0aW5ncyh7XG4gICAgICBvdXRsaW5lRW5hYmxlZDogdHJ1ZSxcbiAgICAgIG91dGxpbmVSZW5kZXJTaGFkb3dtYXA6IHRydWUsXG4gICAgICBvdXRsaW5lU2hhZG93bWFwOiBkdW1teVRleHR1cmVcbiAgICB9KTtcblxuICAgIHRoaXMuc3RhdGUubW9kZWwuZHJhdyh7XG4gICAgICB1bmlmb3JtczogT2JqZWN0LmFzc2lnbih7fSwgdW5pZm9ybXMsIHtcbiAgICAgICAgam9pbnRUeXBlOiAwLFxuICAgICAgICB3aWR0aFNjYWxlOiB0aGlzLnByb3BzLndpZHRoU2NhbGUgKiAxLjNcbiAgICAgIH0pLFxuICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICBkZXB0aFRlc3Q6IGZhbHNlLFxuICAgICAgICAvLyBCaWdnZXN0IHZhbHVlIG5lZWRzIHRvIGdvIGludG8gYnVmZmVyXG4gICAgICAgIGJsZW5kRXF1YXRpb246IEdMLk1BWFxuICAgICAgfSxcbiAgICAgIGZyYW1lYnVmZmVyOiBvdXRsaW5lRnJhbWVidWZmZXJcbiAgICB9KTtcblxuICAgIC8vIE5vdyB1c2UgdGhlIG91dGxpbmUgc2hhZG93bWFwIHRvIHJlbmRlciB0aGUgbGluZXMgKHdpdGggb3V0bGluZXMpXG4gICAgdGhpcy5zdGF0ZS5tb2RlbC51cGRhdGVNb2R1bGVTZXR0aW5ncyh7XG4gICAgICBvdXRsaW5lRW5hYmxlZDogdHJ1ZSxcbiAgICAgIG91dGxpbmVSZW5kZXJTaGFkb3dtYXA6IGZhbHNlLFxuICAgICAgb3V0bGluZVNoYWRvd21hcDogb3V0bGluZUZyYW1lYnVmZmVyXG4gICAgfSk7XG4gICAgdGhpcy5zdGF0ZS5tb2RlbC5kcmF3KHtcbiAgICAgIHVuaWZvcm1zOiBPYmplY3QuYXNzaWduKHt9LCB1bmlmb3Jtcywge1xuICAgICAgICBqb2ludFR5cGU6IE51bWJlcihyb3VuZGVkKSxcbiAgICAgICAgd2lkdGhTY2FsZTogdGhpcy5wcm9wcy53aWR0aFNjYWxlXG4gICAgICB9KSxcbiAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgZGVwdGhUZXN0OiBmYWxzZVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY2FsY3VsYXRlWkxldmVscyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7IGdldFpMZXZlbCB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IHBhdGhUZXNzZWxhdG9yIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgYXR0cmlidXRlLnZhbHVlID0gcGF0aFRlc3NlbGF0b3IuX3VwZGF0ZUF0dHJpYnV0ZSh7XG4gICAgICB0YXJnZXQ6IGF0dHJpYnV0ZS52YWx1ZSxcbiAgICAgIHNpemU6IDEsXG4gICAgICBnZXRWYWx1ZTogKG9iamVjdCwgaW5kZXgpID0+IFtnZXRaTGV2ZWwob2JqZWN0LCBpbmRleCkgfHwgMF1cbiAgICB9KTtcbiAgfVxufVxuXG5QYXRoT3V0bGluZUxheWVyLmxheWVyTmFtZSA9ICdQYXRoT3V0bGluZUxheWVyJztcblBhdGhPdXRsaW5lTGF5ZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuIl19