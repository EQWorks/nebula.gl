"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SnappableMode = void 0;

var _geojsonEditMode = require("./geojson-edit-mode.js");

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class SnappableMode extends _geojsonEditMode.BaseGeoJsonEditMode {
  constructor(handler) {
    super();

    _defineProperty(this, "_handler", void 0);

    _defineProperty(this, "_editHandlePicks", void 0);

    _defineProperty(this, "_startDragSnapHandlePosition", void 0);

    this._handler = handler;
  }

  _getSnappedMouseEvent(event, snapPoint) {
    return Object.assign({}, event, {
      mapCoords: snapPoint,
      pointerDownMapCoords: this._startDragSnapHandlePosition
    });
  }

  _getEditHandlePicks(event) {
    var picks = event.picks;
    var potentialSnapHandle = (0, _geojsonEditMode.getPickedEditHandles)(picks).find(function (handle) {
      return handle.type === 'intermediate';
    });
    var handles = {
      potentialSnapHandle: potentialSnapHandle
    };
    var pickedHandle = (0, _geojsonEditMode.getPickedEditHandle)(event.pointerDownPicks);

    if (pickedHandle) {
      return _objectSpread({}, handles, {
        pickedHandle: pickedHandle
      });
    }

    return handles;
  }

  _updatePickedHandlePosition(editAction) {
    var _ref = this._editHandlePicks || {},
        pickedHandle = _ref.pickedHandle;

    if (pickedHandle && editAction) {
      var editContext = editAction.editContext,
          updatedData = editAction.updatedData;
      var featureIndexes = editContext.featureIndexes;

      for (var i = 0; i < featureIndexes.length; i++) {
        var selectedIndex = featureIndexes[i];
        var updatedFeature = updatedData.features[selectedIndex];
        var positionIndexes = pickedHandle.positionIndexes,
            featureIndex = pickedHandle.featureIndex;

        if (selectedIndex >= 0 && featureIndex === selectedIndex) {
          var coordinates = updatedFeature.geometry.coordinates; // $FlowFixMe

          pickedHandle.position = positionIndexes.reduce(function (a, b) {
            return a[b];
          }, coordinates);
        }
      }
    }
  } // If additionalSnapTargets is present in modeConfig and is populated, this
  // method will return those features along with the features
  // that live in the current layer. Otherwise, this method will simply return the
  // features from the current layer


  _getSnapTargets(props) {
    var _ref2 = props.modeConfig || {},
        additionalSnapTargets = _ref2.additionalSnapTargets;

    additionalSnapTargets = additionalSnapTargets || [];

    var features = _toConsumableArray(props.data.features).concat(_toConsumableArray(additionalSnapTargets));

    return features;
  }

  _getNonPickedIntermediateHandles(props) {
    var handles = [];

    var features = this._getSnapTargets(props);

    for (var i = 0; i < features.length; i++) {
      // Filter out the currently selected feature(s)
      var isCurrentIndexFeatureNotSelected = !props.selectedIndexes.includes(i);

      if (isCurrentIndexFeatureNotSelected) {
        var geometry = features[i].geometry;
        handles.push.apply(handles, _toConsumableArray((0, _geojsonEditMode.getEditHandlesForGeometry)(geometry, i, 'intermediate')));
      }
    }

    return handles;
  } // If no snap handle has been picked, only display the edit handles of the
  // selected feature. If a snap handle has been picked, display said snap handle
  // along with all snappable points on all non-selected features.


  getEditHandlesAdapter(picks, mapCoords, props) {
    var _ref3 = props.modeConfig || {},
        enableSnapping = _ref3.enableSnapping;

    var handles = _toConsumableArray(this._handler.getEditHandlesAdapter(picks, mapCoords, props));

    if (!enableSnapping) return handles;

    var _ref4 = this._editHandlePicks || {},
        pickedHandle = _ref4.pickedHandle;

    if (pickedHandle) {
      handles.push.apply(handles, _toConsumableArray(this._getNonPickedIntermediateHandles(props)).concat([pickedHandle]));
      return handles;
    }

    var features = props.data.features;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = props.selectedIndexes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var index = _step.value;

        if (index < features.length) {
          var geometry = features[index].geometry;
          handles.push.apply(handles, _toConsumableArray((0, _geojsonEditMode.getEditHandlesForGeometry)(geometry, index, 'snap')));
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return handles.filter(Boolean);
  }

  _getSnapAwareEvent(event) {
    var _ref5 = this._editHandlePicks || {},
        potentialSnapHandle = _ref5.potentialSnapHandle;

    return potentialSnapHandle && potentialSnapHandle.position ? this._getSnappedMouseEvent(event, potentialSnapHandle.position) : event;
  }

  handleStartDraggingAdapter(event, props) {
    this._startDragSnapHandlePosition = ((0, _geojsonEditMode.getPickedEditHandle)(event.picks) || {}).position;
    return this._handler.handleStartDraggingAdapter(event, props);
  }

  handleStopDraggingAdapter(event, props) {
    var modeActionSummary = this._handler.handleStopDraggingAdapter(this._getSnapAwareEvent(event), props);

    this._editHandlePicks = null;
    return modeActionSummary;
  }

  getCursorAdapter(props) {
    return this._handler.getCursorAdapter(props);
  }

  handlePointerMoveAdapter(event, props) {
    var _ref6 = props.modeConfig || {},
        enableSnapping = _ref6.enableSnapping;

    if (enableSnapping) {
      this._editHandlePicks = this._getEditHandlePicks(event);
    }

    var modeActionSummary = this._handler.handlePointerMoveAdapter(this._getSnapAwareEvent(event), props);

    var editAction = modeActionSummary.editAction;

    if (editAction) {
      this._updatePickedHandlePosition(editAction);
    }

    return modeActionSummary;
  }

}

exports.SnappableMode = SnappableMode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvc25hcHBhYmxlLW1vZGUuanMiXSwibmFtZXMiOlsiU25hcHBhYmxlTW9kZSIsIkJhc2VHZW9Kc29uRWRpdE1vZGUiLCJjb25zdHJ1Y3RvciIsImhhbmRsZXIiLCJfaGFuZGxlciIsIl9nZXRTbmFwcGVkTW91c2VFdmVudCIsImV2ZW50Iiwic25hcFBvaW50IiwiT2JqZWN0IiwiYXNzaWduIiwibWFwQ29vcmRzIiwicG9pbnRlckRvd25NYXBDb29yZHMiLCJfc3RhcnREcmFnU25hcEhhbmRsZVBvc2l0aW9uIiwiX2dldEVkaXRIYW5kbGVQaWNrcyIsInBpY2tzIiwicG90ZW50aWFsU25hcEhhbmRsZSIsImZpbmQiLCJoYW5kbGUiLCJ0eXBlIiwiaGFuZGxlcyIsInBpY2tlZEhhbmRsZSIsInBvaW50ZXJEb3duUGlja3MiLCJfdXBkYXRlUGlja2VkSGFuZGxlUG9zaXRpb24iLCJlZGl0QWN0aW9uIiwiX2VkaXRIYW5kbGVQaWNrcyIsImVkaXRDb250ZXh0IiwidXBkYXRlZERhdGEiLCJmZWF0dXJlSW5kZXhlcyIsImkiLCJsZW5ndGgiLCJzZWxlY3RlZEluZGV4IiwidXBkYXRlZEZlYXR1cmUiLCJmZWF0dXJlcyIsInBvc2l0aW9uSW5kZXhlcyIsImZlYXR1cmVJbmRleCIsImNvb3JkaW5hdGVzIiwiZ2VvbWV0cnkiLCJwb3NpdGlvbiIsInJlZHVjZSIsImEiLCJiIiwiX2dldFNuYXBUYXJnZXRzIiwicHJvcHMiLCJtb2RlQ29uZmlnIiwiYWRkaXRpb25hbFNuYXBUYXJnZXRzIiwiZGF0YSIsIl9nZXROb25QaWNrZWRJbnRlcm1lZGlhdGVIYW5kbGVzIiwiaXNDdXJyZW50SW5kZXhGZWF0dXJlTm90U2VsZWN0ZWQiLCJzZWxlY3RlZEluZGV4ZXMiLCJpbmNsdWRlcyIsInB1c2giLCJnZXRFZGl0SGFuZGxlc0FkYXB0ZXIiLCJlbmFibGVTbmFwcGluZyIsImluZGV4IiwiZmlsdGVyIiwiQm9vbGVhbiIsIl9nZXRTbmFwQXdhcmVFdmVudCIsImhhbmRsZVN0YXJ0RHJhZ2dpbmdBZGFwdGVyIiwiaGFuZGxlU3RvcERyYWdnaW5nQWRhcHRlciIsIm1vZGVBY3Rpb25TdW1tYXJ5IiwiZ2V0Q3Vyc29yQWRhcHRlciIsImhhbmRsZVBvaW50ZXJNb3ZlQWRhcHRlciJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQVVBOzs7Ozs7Ozs7Ozs7OztBQVNPLE1BQU1BLGFBQU4sU0FBNEJDLG9DQUE1QixDQUFnRDtBQUtyREMsRUFBQUEsV0FBVyxDQUFDQyxPQUFELEVBQStCO0FBQ3hDOztBQUR3Qzs7QUFBQTs7QUFBQTs7QUFFeEMsU0FBS0MsUUFBTCxHQUFnQkQsT0FBaEI7QUFDRDs7QUFFREUsRUFBQUEscUJBQXFCLENBQUNDLEtBQUQsRUFBZ0JDLFNBQWhCLEVBQXVEO0FBQzFFLFdBQU9DLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjLEVBQWQsRUFBa0JILEtBQWxCLEVBQXlCO0FBQzlCSSxNQUFBQSxTQUFTLEVBQUVILFNBRG1CO0FBRTlCSSxNQUFBQSxvQkFBb0IsRUFBRSxLQUFLQztBQUZHLEtBQXpCLENBQVA7QUFJRDs7QUFFREMsRUFBQUEsbUJBQW1CLENBQUNQLEtBQUQsRUFBdUM7QUFBQSxRQUNoRFEsS0FEZ0QsR0FDdENSLEtBRHNDLENBQ2hEUSxLQURnRDtBQUd4RCxRQUFNQyxtQkFBbUIsR0FBRywyQ0FBcUJELEtBQXJCLEVBQTRCRSxJQUE1QixDQUMxQixVQUFBQyxNQUFNO0FBQUEsYUFBSUEsTUFBTSxDQUFDQyxJQUFQLEtBQWdCLGNBQXBCO0FBQUEsS0FEb0IsQ0FBNUI7QUFHQSxRQUFNQyxPQUFPLEdBQUc7QUFBRUosTUFBQUEsbUJBQW1CLEVBQW5CQTtBQUFGLEtBQWhCO0FBRUEsUUFBTUssWUFBWSxHQUFHLDBDQUFvQmQsS0FBSyxDQUFDZSxnQkFBMUIsQ0FBckI7O0FBQ0EsUUFBSUQsWUFBSixFQUFrQjtBQUNoQiwrQkFBWUQsT0FBWjtBQUFxQkMsUUFBQUEsWUFBWSxFQUFaQTtBQUFyQjtBQUNEOztBQUVELFdBQU9ELE9BQVA7QUFDRDs7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QUN4QixLQUFLTCxrQkFBTCxDQUF3QmxELEtBQXhCLENBRHdCLEVBRXhCb0MsS0FGd0IsQ0FBMUI7O0FBUDJELFFBV25EbkIsVUFYbUQsR0FXcENvQyxpQkFYb0MsQ0FXbkRwQyxVQVhtRDs7QUFZM0QsUUFBSUEsVUFBSixFQUFnQjtBQUNkLFdBQUtELDJCQUFMLENBQWlDQyxVQUFqQztBQUNEOztBQUVELFdBQU9vQyxpQkFBUDtBQUNEOztBQXhLb0QiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuXG5pbXBvcnQgdHlwZSB7IEZlYXR1cmUsIEZlYXR1cmVDb2xsZWN0aW9uLCBQb3NpdGlvbiB9IGZyb20gJy4uL2dlb2pzb24tdHlwZXMuanMnO1xuaW1wb3J0IHR5cGUge1xuICBQb2ludGVyTW92ZUV2ZW50LFxuICBTdGFydERyYWdnaW5nRXZlbnQsXG4gIFN0b3BEcmFnZ2luZ0V2ZW50LFxuICBNb2RlUHJvcHNcbn0gZnJvbSAnLi4vdHlwZXMuanMnO1xuaW1wb3J0IHR5cGUgeyBFZGl0SGFuZGxlLCBHZW9Kc29uRWRpdEFjdGlvbiB9IGZyb20gJy4vZ2VvanNvbi1lZGl0LW1vZGUuanMnO1xuaW1wb3J0IHtcbiAgQmFzZUdlb0pzb25FZGl0TW9kZSxcbiAgZ2V0UGlja2VkRWRpdEhhbmRsZSxcbiAgZ2V0UGlja2VkRWRpdEhhbmRsZXMsXG4gIGdldEVkaXRIYW5kbGVzRm9yR2VvbWV0cnlcbn0gZnJvbSAnLi9nZW9qc29uLWVkaXQtbW9kZS5qcyc7XG5cbnR5cGUgSGFuZGxlUGlja3MgPSB7IHBpY2tlZEhhbmRsZT86IEVkaXRIYW5kbGUsIHBvdGVudGlhbFNuYXBIYW5kbGU/OiBFZGl0SGFuZGxlIH07XG5cbmV4cG9ydCBjbGFzcyBTbmFwcGFibGVNb2RlIGV4dGVuZHMgQmFzZUdlb0pzb25FZGl0TW9kZSB7XG4gIF9oYW5kbGVyOiBCYXNlR2VvSnNvbkVkaXRNb2RlO1xuICBfZWRpdEhhbmRsZVBpY2tzOiA/SGFuZGxlUGlja3M7XG4gIF9zdGFydERyYWdTbmFwSGFuZGxlUG9zaXRpb246IFBvc2l0aW9uO1xuXG4gIGNvbnN0cnVjdG9yKGhhbmRsZXI6IEJhc2VHZW9Kc29uRWRpdE1vZGUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2hhbmRsZXIgPSBoYW5kbGVyO1xuICB9XG5cbiAgX2dldFNuYXBwZWRNb3VzZUV2ZW50KGV2ZW50OiBPYmplY3QsIHNuYXBQb2ludDogUG9zaXRpb24pOiBQb2ludGVyTW92ZUV2ZW50IHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZXZlbnQsIHtcbiAgICAgIG1hcENvb3Jkczogc25hcFBvaW50LFxuICAgICAgcG9pbnRlckRvd25NYXBDb29yZHM6IHRoaXMuX3N0YXJ0RHJhZ1NuYXBIYW5kbGVQb3NpdGlvblxuICAgIH0pO1xuICB9XG5cbiAgX2dldEVkaXRIYW5kbGVQaWNrcyhldmVudDogUG9pbnRlck1vdmVFdmVudCk6IEhhbmRsZVBpY2tzIHtcbiAgICBjb25zdCB7IHBpY2tzIH0gPSBldmVudDtcblxuICAgIGNvbnN0IHBvdGVudGlhbFNuYXBIYW5kbGUgPSBnZXRQaWNrZWRFZGl0SGFuZGxlcyhwaWNrcykuZmluZChcbiAgICAgIGhhbmRsZSA9PiBoYW5kbGUudHlwZSA9PT0gJ2ludGVybWVkaWF0ZSdcbiAgICApO1xuICAgIGNvbnN0IGhhbmRsZXMgPSB7IHBvdGVudGlhbFNuYXBIYW5kbGUgfTtcblxuICAgIGNvbnN0IHBpY2tlZEhhbmRsZSA9IGdldFBpY2tlZEVkaXRIYW5kbGUoZXZlbnQucG9pbnRlckRvd25QaWNrcyk7XG4gICAgaWYgKHBpY2tlZEhhbmRsZSkge1xuICAgICAgcmV0dXJuIHsgLi4uaGFuZGxlcywgcGlja2VkSGFuZGxlIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhbmRsZXM7XG4gIH1cblxuICBfdXBkYXRlUGlja2VkSGFuZGxlUG9zaXRpb24oZWRpdEFjdGlvbjogR2VvSnNvbkVkaXRBY3Rpb24pIHtcbiAgICBjb25zdCB7IHBpY2tlZEhhbmRsZSB9ID0gdGhpcy5fZWRpdEhhbmRsZVBpY2tzIHx8IHt9O1xuXG4gICAgaWYgKHBpY2tlZEhhbmRsZSAmJiBlZGl0QWN0aW9uKSB7XG4gICAgICBjb25zdCB7IGVkaXRDb250ZXh0LCB1cGRhdGVkRGF0YSB9ID0gZWRpdEFjdGlvbjtcbiAgICAgIGNvbnN0IHsgZmVhdHVyZUluZGV4ZXMgfSA9IGVkaXRDb250ZXh0O1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZlYXR1cmVJbmRleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkSW5kZXggPSBmZWF0dXJlSW5kZXhlc1tpXTtcbiAgICAgICAgY29uc3QgdXBkYXRlZEZlYXR1cmUgPSB1cGRhdGVkRGF0YS5mZWF0dXJlc1tzZWxlY3RlZEluZGV4XTtcblxuICAgICAgICBjb25zdCB7IHBvc2l0aW9uSW5kZXhlcywgZmVhdHVyZUluZGV4IH0gPSBwaWNrZWRIYW5kbGU7XG4gICAgICAgIGlmIChzZWxlY3RlZEluZGV4ID49IDAgJiYgZmVhdHVyZUluZGV4ID09PSBzZWxlY3RlZEluZGV4KSB7XG4gICAgICAgICAgY29uc3QgeyBjb29yZGluYXRlcyB9ID0gdXBkYXRlZEZlYXR1cmUuZ2VvbWV0cnk7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgICAgIHBpY2tlZEhhbmRsZS5wb3NpdGlvbiA9IHBvc2l0aW9uSW5kZXhlcy5yZWR1Y2UoXG4gICAgICAgICAgICAoYTogYW55W10sIGI6IG51bWJlcikgPT4gYVtiXSxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIElmIGFkZGl0aW9uYWxTbmFwVGFyZ2V0cyBpcyBwcmVzZW50IGluIG1vZGVDb25maWcgYW5kIGlzIHBvcHVsYXRlZCwgdGhpc1xuICAvLyBtZXRob2Qgd2lsbCByZXR1cm4gdGhvc2UgZmVhdHVyZXMgYWxvbmcgd2l0aCB0aGUgZmVhdHVyZXNcbiAgLy8gdGhhdCBsaXZlIGluIHRoZSBjdXJyZW50IGxheWVyLiBPdGhlcndpc2UsIHRoaXMgbWV0aG9kIHdpbGwgc2ltcGx5IHJldHVybiB0aGVcbiAgLy8gZmVhdHVyZXMgZnJvbSB0aGUgY3VycmVudCBsYXllclxuICBfZ2V0U25hcFRhcmdldHMocHJvcHM6IE1vZGVQcm9wczxGZWF0dXJlQ29sbGVjdGlvbj4pOiBGZWF0dXJlW10ge1xuICAgIGxldCB7IGFkZGl0aW9uYWxTbmFwVGFyZ2V0cyB9ID0gcHJvcHMubW9kZUNvbmZpZyB8fCB7fTtcbiAgICBhZGRpdGlvbmFsU25hcFRhcmdldHMgPSBhZGRpdGlvbmFsU25hcFRhcmdldHMgfHwgW107XG5cbiAgICBjb25zdCBmZWF0dXJlcyA9IFsuLi5wcm9wcy5kYXRhLmZlYXR1cmVzLCAuLi5hZGRpdGlvbmFsU25hcFRhcmdldHNdO1xuICAgIHJldHVybiBmZWF0dXJlcztcbiAgfVxuXG4gIF9nZXROb25QaWNrZWRJbnRlcm1lZGlhdGVIYW5kbGVzKHByb3BzOiBNb2RlUHJvcHM8RmVhdHVyZUNvbGxlY3Rpb24+KTogRWRpdEhhbmRsZVtdIHtcbiAgICBjb25zdCBoYW5kbGVzID0gW107XG4gICAgY29uc3QgZmVhdHVyZXMgPSB0aGlzLl9nZXRTbmFwVGFyZ2V0cyhwcm9wcyk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZmVhdHVyZShzKVxuICAgICAgY29uc3QgaXNDdXJyZW50SW5kZXhGZWF0dXJlTm90U2VsZWN0ZWQgPSAhcHJvcHMuc2VsZWN0ZWRJbmRleGVzLmluY2x1ZGVzKGkpO1xuXG4gICAgICBpZiAoaXNDdXJyZW50SW5kZXhGZWF0dXJlTm90U2VsZWN0ZWQpIHtcbiAgICAgICAgY29uc3QgeyBnZW9tZXRyeSB9ID0gZmVhdHVyZXNbaV07XG4gICAgICAgIGhhbmRsZXMucHVzaCguLi5nZXRFZGl0SGFuZGxlc0Zvckdlb21ldHJ5KGdlb21ldHJ5LCBpLCAnaW50ZXJtZWRpYXRlJykpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGFuZGxlcztcbiAgfVxuXG4gIC8vIElmIG5vIHNuYXAgaGFuZGxlIGhhcyBiZWVuIHBpY2tlZCwgb25seSBkaXNwbGF5IHRoZSBlZGl0IGhhbmRsZXMgb2YgdGhlXG4gIC8vIHNlbGVjdGVkIGZlYXR1cmUuIElmIGEgc25hcCBoYW5kbGUgaGFzIGJlZW4gcGlja2VkLCBkaXNwbGF5IHNhaWQgc25hcCBoYW5kbGVcbiAgLy8gYWxvbmcgd2l0aCBhbGwgc25hcHBhYmxlIHBvaW50cyBvbiBhbGwgbm9uLXNlbGVjdGVkIGZlYXR1cmVzLlxuICBnZXRFZGl0SGFuZGxlc0FkYXB0ZXIoXG4gICAgcGlja3M6ID9BcnJheTxPYmplY3Q+LFxuICAgIG1hcENvb3JkczogP1Bvc2l0aW9uLFxuICAgIHByb3BzOiBNb2RlUHJvcHM8RmVhdHVyZUNvbGxlY3Rpb24+XG4gICk6IGFueVtdIHtcbiAgICBjb25zdCB7IGVuYWJsZVNuYXBwaW5nIH0gPSBwcm9wcy5tb2RlQ29uZmlnIHx8IHt9O1xuICAgIGNvbnN0IGhhbmRsZXMgPSBbLi4udGhpcy5faGFuZGxlci5nZXRFZGl0SGFuZGxlc0FkYXB0ZXIocGlja3MsIG1hcENvb3JkcywgcHJvcHMpXTtcblxuICAgIGlmICghZW5hYmxlU25hcHBpbmcpIHJldHVybiBoYW5kbGVzO1xuICAgIGNvbnN0IHsgcGlja2VkSGFuZGxlIH0gPSB0aGlzLl9lZGl0SGFuZGxlUGlja3MgfHwge307XG5cbiAgICBpZiAocGlja2VkSGFuZGxlKSB7XG4gICAgICBoYW5kbGVzLnB1c2goLi4udGhpcy5fZ2V0Tm9uUGlja2VkSW50ZXJtZWRpYXRlSGFuZGxlcyhwcm9wcyksIHBpY2tlZEhhbmRsZSk7XG4gICAgICByZXR1cm4gaGFuZGxlcztcbiAgICB9XG5cbiAgICBjb25zdCB7IGZlYXR1cmVzIH0gPSBwcm9wcy5kYXRhO1xuICAgIGZvciAoY29uc3QgaW5kZXggb2YgcHJvcHMuc2VsZWN0ZWRJbmRleGVzKSB7XG4gICAgICBpZiAoaW5kZXggPCBmZWF0dXJlcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgeyBnZW9tZXRyeSB9ID0gZmVhdHVyZXNbaW5kZXhdO1xuICAgICAgICBoYW5kbGVzLnB1c2goLi4uZ2V0RWRpdEhhbmRsZXNGb3JHZW9tZXRyeShnZW9tZXRyeSwgaW5kZXgsICdzbmFwJykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBoYW5kbGVzLmZpbHRlcihCb29sZWFuKTtcbiAgfVxuXG4gIF9nZXRTbmFwQXdhcmVFdmVudChldmVudDogT2JqZWN0KTogT2JqZWN0IHtcbiAgICBjb25zdCB7IHBvdGVudGlhbFNuYXBIYW5kbGUgfSA9IHRoaXMuX2VkaXRIYW5kbGVQaWNrcyB8fCB7fTtcblxuICAgIHJldHVybiBwb3RlbnRpYWxTbmFwSGFuZGxlICYmIHBvdGVudGlhbFNuYXBIYW5kbGUucG9zaXRpb25cbiAgICAgID8gdGhpcy5fZ2V0U25hcHBlZE1vdXNlRXZlbnQoZXZlbnQsIHBvdGVudGlhbFNuYXBIYW5kbGUucG9zaXRpb24pXG4gICAgICA6IGV2ZW50O1xuICB9XG5cbiAgaGFuZGxlU3RhcnREcmFnZ2luZ0FkYXB0ZXIoXG4gICAgZXZlbnQ6IFN0YXJ0RHJhZ2dpbmdFdmVudCxcbiAgICBwcm9wczogTW9kZVByb3BzPEZlYXR1cmVDb2xsZWN0aW9uPlxuICApOiA/R2VvSnNvbkVkaXRBY3Rpb24ge1xuICAgIHRoaXMuX3N0YXJ0RHJhZ1NuYXBIYW5kbGVQb3NpdGlvbiA9IChnZXRQaWNrZWRFZGl0SGFuZGxlKGV2ZW50LnBpY2tzKSB8fCB7fSkucG9zaXRpb247XG4gICAgcmV0dXJuIHRoaXMuX2hhbmRsZXIuaGFuZGxlU3RhcnREcmFnZ2luZ0FkYXB0ZXIoZXZlbnQsIHByb3BzKTtcbiAgfVxuXG4gIGhhbmRsZVN0b3BEcmFnZ2luZ0FkYXB0ZXIoXG4gICAgZXZlbnQ6IFN0b3BEcmFnZ2luZ0V2ZW50LFxuICAgIHByb3BzOiBNb2RlUHJvcHM8RmVhdHVyZUNvbGxlY3Rpb24+XG4gICk6ID9HZW9Kc29uRWRpdEFjdGlvbiB7XG4gICAgY29uc3QgbW9kZUFjdGlvblN1bW1hcnkgPSB0aGlzLl9oYW5kbGVyLmhhbmRsZVN0b3BEcmFnZ2luZ0FkYXB0ZXIoXG4gICAgICB0aGlzLl9nZXRTbmFwQXdhcmVFdmVudChldmVudCksXG4gICAgICBwcm9wc1xuICAgICk7XG5cbiAgICB0aGlzLl9lZGl0SGFuZGxlUGlja3MgPSBudWxsO1xuICAgIHJldHVybiBtb2RlQWN0aW9uU3VtbWFyeTtcbiAgfVxuXG4gIGdldEN1cnNvckFkYXB0ZXIocHJvcHM6IE1vZGVQcm9wczxGZWF0dXJlQ29sbGVjdGlvbj4pOiA/c3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5faGFuZGxlci5nZXRDdXJzb3JBZGFwdGVyKHByb3BzKTtcbiAgfVxuXG4gIGhhbmRsZVBvaW50ZXJNb3ZlQWRhcHRlcihcbiAgICBldmVudDogUG9pbnRlck1vdmVFdmVudCxcbiAgICBwcm9wczogTW9kZVByb3BzPEZlYXR1cmVDb2xsZWN0aW9uPlxuICApOiB7IGVkaXRBY3Rpb246ID9HZW9Kc29uRWRpdEFjdGlvbiwgY2FuY2VsTWFwUGFuOiBib29sZWFuIH0ge1xuICAgIGNvbnN0IHsgZW5hYmxlU25hcHBpbmcgfSA9IHByb3BzLm1vZGVDb25maWcgfHwge307XG5cbiAgICBpZiAoZW5hYmxlU25hcHBpbmcpIHtcbiAgICAgIHRoaXMuX2VkaXRIYW5kbGVQaWNrcyA9IHRoaXMuX2dldEVkaXRIYW5kbGVQaWNrcyhldmVudCk7XG4gICAgfVxuXG4gICAgY29uc3QgbW9kZUFjdGlvblN1bW1hcnkgPSB0aGlzLl9oYW5kbGVyLmhhbmRsZVBvaW50ZXJNb3ZlQWRhcHRlcihcbiAgICAgIHRoaXMuX2dldFNuYXBBd2FyZUV2ZW50KGV2ZW50KSxcbiAgICAgIHByb3BzXG4gICAgKTtcbiAgICBjb25zdCB7IGVkaXRBY3Rpb24gfSA9IG1vZGVBY3Rpb25TdW1tYXJ5O1xuICAgIGlmIChlZGl0QWN0aW9uKSB7XG4gICAgICB0aGlzLl91cGRhdGVQaWNrZWRIYW5kbGVQb3NpdGlvbihlZGl0QWN0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbW9kZUFjdGlvblN1bW1hcnk7XG4gIH1cbn1cbiJdfQ==